# [CSP-S 2021] 括号序列

## 题目描述

小 w 在赛场上遇到了这样一个题：一个长度为 $n$ 且符合规范的括号序列，其有些位置已经确定了，有些位置尚未确定，求这样的括号序列一共有多少个。

身经百战的小 w 当然一眼就秒了这题，不仅如此，他还觉得一场正式比赛出这么简单的模板题也太小儿科了，于是他把这题进行了加强之后顺手扔给了小 c。

具体而言，小 w 定义“超级括号序列”是由字符 `(`、`)`、`*` 组成的字符串，并且对于某个给定的常数 $k$，给出了“符合规范的超级括号序列”的定义如下：

1. `()`、`(S)` 均是符合规范的超级括号序列，其中 `S` 表示任意一个仅由**不超过** k **个**字符 `*` 组成的非空字符串（以下两条规则中的 `S` 均为此含义）；
2. 如果字符串 `A` 和 `B` 均为符合规范的超级括号序列，那么字符串 `AB`、`ASB` 均为符合规范的超级括号序列，其中 `AB` 表示把字符串 `A` 和字符串 `B` 拼接在一起形成的字符串；
3. 如果字符串 `A` 为符合规范的超级括号序列，那么字符串 `(A)`、`(SA)`、`(AS)` 均为符合规范的超级括号序列。
4. 所有符合规范的超级括号序列均可通过上述 3 条规则得到。

例如，若 $k = 3$，则字符串 `((**()*(*))*)(***)` 是符合规范的超级括号序列，但字符串 `*()`、`(*()*)`、`((**))*)`、`(****(*))` 均不是。特别地，空字符串也不被视为符合规范的超级括号序列。

现在给出一个长度为 $n$ 的超级括号序列，其中有一些位置的字符已经确定，另外一些位置的字符尚未确定（用 `?` 表示）。小 w 希望能计算出：有多少种将所有尚未确定的字符一一确定的方法，使得得到的字符串是一个符合规范的超级括号序列？

可怜的小 c 并不会做这道题，于是只好请求你来帮忙。

## 输入格式

第一行，两个正整数 $n, k$。

第二行，一个长度为 $n$ 且仅由 `(`、`)`、`*`、`?` 构成的字符串 $S$。

## 输出格式

输出一个非负整数表示答案对 ${10}^9 + 7$ 取模的结果。

## 样例 #1

### 样例输入 #1

```
7 3
(*??*??
```

### 样例输出 #1

```
5
```

## 样例 #2

### 样例输入 #2

```
10 2
???(*??(?)
```

### 样例输出 #2

```
19
```

## 样例 #3

### 样例输入 #3

```
见附件中的 bracket/bracket3.in
```

### 样例输出 #3

```
见附件中的 bracket/bracket3.ans
```

## 样例 #4

### 样例输入 #4

```
见附件中的 bracket/bracket4.in
```

### 样例输出 #4

```
见附件中的 bracket/bracket4.ans
```

## 提示

**【样例解释 #1】**

如下几种方案是符合规范的：

```plain
(**)*()
(**(*))
(*(**))
(*)**()
(*)(**)
```

**【数据范围】**

|  测试点编号  | $n \le$ |        特殊性质        |
| :----------: | :-----: | :--------------------: |
|  $1 \sim 3$  |  $15$   |           无           |
|  $4 \sim 8$  |  $40$   |           无           |
| $9 \sim 13$  |  $100$  |           无           |
| $14 \sim 15$ |  $500$  | $S$ 串中仅含有字符 `?` |
| $16 \sim 20$ |  $500$  |           无           |

对于 $100 \%$ 的数据，$1 \le k \le n \le 500$。

## 解答

容易发现这道题的状态表示是比较麻烦的，这里选择分类讨论标号

0. 全是*，对应的是S

1. （······），即左右直接被括号包裹且最左边括号与最右边的括号相互匹配

2. (······)* *（······） * *即左边以括号序列开头，右边以`*`结尾

3. (······)* *（······） * * (·······),即左边以括号序列开头，右边以括号序列结尾

4. qwq   * * (······) *  *（······）即左边以`*`开头，右边以括号序列结尾

5. ** (······) **（······） * *,即左边以`*`开头，右边以`*`结尾

2,3,4,5,6都是对应拼接的情况，因为处理区间所以要考虑左右

这里解释一下为什么说包含：其中 `S` 表示任意一个仅由**不超过** **k** **个**字符 `*` 组成的非空字符串，

***dp[i] [j] [k] k表示编号，从0开始***

dp[i] [j] [0] = 略

1. dp[i] [j] [1] = dp[i+1] [j-1] [0] + dp[i+1] [j -1] [2]（AS可以直接上括号）+dp[i+1] [j-1] [3] (A也可以直接上括号) + dp[i+1] [j -1]   [4] (SA可以直接上括号) * compare(i,j) [compare 是 判断第 i 位 和 第 j 位能否匹配的函数，能则1，否则0]
2. dp[i] [j] [2] = dp[i] [k-1] [3] * dp[k] [r] [0],k 属于i~r，意会即可，写法不规范
3. dp[i] [j] [3] =  dp[i] [j] [1] （直接符合定义) + dp[i] [k] [2 or 3] * dp[k+1] [j] [1] (这里重点关注2,4对称，加一个就行，防重,统一从左向右扩列)
4. dp[i] [j] [4] = dp[i] [k] [4 or 5] * dp[k +1] [j] [1] (理由同上)
5. dp[i] [j] [5] = dp[i] [k] [4] * dp[k+1] [j] [0] (左边以*开头，右边以括号结尾 * 全是*） + dp[i] [j] [0]（两者定义上吻合)

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define mod 1000000007
int n,k,dp[510][510][6];
char s[510];
bool compare(int a,int b) {return (s[a]=='('||s[a]=='?')&&(s[b]==')'||s[b]=='?');}
signed main(){
    n=read(),k=read();
    scanf("%s",s+1);
    For(i,1,n) dp[i][i-1][0]=1;//当len=1的时候，带入到下面几行程序，你就明白为什么这么初始化了
    For(len,1,n){
        For(l,1,n-len+1){
            int r=l+len-1;
            if(len<=k) dp[l][r][0]=dp[l][r-1][0]&&(s[r]=='*'||s[r]=='?');
            if(len>=2){
                if(compare(l,r)) dp[l][r][1]=(dp[l+1][r-1][0]+dp[l+1][r-1][2]+dp[l+1][r-1][3]+dp[l+1][r-1][4])%mod;
                For(i,l,r-1){
                    dp[l][r][2]=(dp[l][r][2]+dp[l][i][3]*dp[i+1][r][0])%mod;
                    dp[l][r][3]=(dp[l][r][3]+(dp[l][i][2]+dp[l][i][3])*dp[i+1][r][1])%mod;
                    dp[l][r][4]=(dp[l][r][4]+(dp[l][i][4]+dp[l][i][5])*dp[i+1][r][1])%mod;
                    dp[l][r][5]=(dp[l][r][5]+dp[l][i][4]*dp[i+1][r][0])%mod;
                }
            }
            dp[l][r][5]=(dp[l][r][5]+dp[l][r][0])%mod;
            dp[l][r][3]=(dp[l][r][3]+dp[l][r][1])%mod;
        }
    }
    printf("%lld\n",dp[1][n][3]);
}
```

这道题分类讨论比较猥琐，算是一道很标准的提高题了。
